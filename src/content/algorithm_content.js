export const ALGORITHMS_CONTENT = {
    header: 'Алгоритмы',
    lists: [{
        header: 'Git по книге',
        items: [`<a href="https://github.com/egonSchiele/grokking_algorithms" target="_blank">egonSchiele/grokking_algorithms</a>`]
    }, {
        header: 'Время выполнения',
        items: [
            'Время выполнения алгоритмов растет с разной скоростью.',
            'О-большое - как возрастает время выполнения с ростом списка.',
            'О-большое - не сообщает время в секундах, позволяет сравнить количество операций.',
            'О-большое - определяет время выолнения в худшем случае.',
            'Константы не учитываются: O(N/2) = O(N).',
            '',
            'Линейное - максимальное количество попыток совпадает с размером списка О(n).',
            'Логарифмическое - O(logN)',
            'O(N*logN) - эффективные алгоритмы сортировки.',
            'O(N*N) - медленные алгоритмы сортировки.',
            'O(N!) - очень медленные алгоритмы сортировки.',
        ],
    }, {
        header: 'Бинарный поиск',
        items: [
            'На вход - отсортирвоанный список.',
            'С каждой попыткой - отсекается половина оставшихся элементов.',
            'Нужно logN шагов.'
        ],
    }, {
        header: 'Массивы и связные списки',
        items: [
            'Массивы:',
            {
                items: [
                    'Хранятся в памяти непрерывно.',
                    'При добавлении нового элемента, если рядом нет свободного места в памяти:',
                    {items: ['Переносить весь массив в другое место памяти.', 'Изначально указать размер больше - неэффективно расходуется память.']},
                    'Быстрое чтение элемента с любой позиции O(1).',
                    'Вставка элемента O(N).',
                    'Удаление элемента O(N).',

                ],
            },
            'Связные списки:',
            {
                items: [
                    'Элементы списка размещаются в памяти где угодно, так как в каждом элементе хранится адрес следующего.',
                    'При добавлении элемента нет таких проблем.',
                    'Чтобы прочитать элемент из середины, нужно пройти через весь список. O(N).',
                    'Вставка элемента O(1).',
                    'Удаление элемента O(1) - если можно мгновенно получить доступ к удаляемому элементу.',
                ],
            },
        ],
    }, {
        header: 'Сортировка выбором',
        items: [
            'Для сортировки по возрстанию сначала находим самый большой элемент, затем самый большой из оставшихся и тд.',
            'О(N*N)',
        ],
    },{
        header: 'Рекурсия',
        items: [
            'Это когда функция вызывает саму себя.',
            'Применяется тогда, когда решение становится более понятным.',
            'Рекурсия не убыстряет работу, иногда решение с циклами даже быстрее.',
            'Состоит  из базового случая (когда остановится) и рекурсивного (функция вызывает сама себя).',
            'Важно понимать - стек вызовов: когда функция вызыывается из другой функции, вызывающая функция приостанавливается, а не заканчивает работу; после выполнения вызыванной функции управление передается обратно к вызывающей и она продолжает работу.',
            'Рекурсивные функции тоже используют стек вызывов',
            'Сохранение все информации для каждого вызывова функции - могут быть большие затраты памяти:',
            {
                items:['Использовть цикл вместо рекурсии.', 'Хвостовая рекурсия.']
            }
        ],
    },{
        header: 'Разделяй и властвуй',
        items: [
            'Алгоритмы на базе этой стратегии - рекурсивные.',
            'Два шага:',
            {
                items:['Определить базовый случай - простейший из всех возможных.', 'Задача делится или сокращается, пока не будет сведена к базовому случаю.']
            },
            'Алгоритм Евклида.',
            'Для массивов базовый случай - пустой массив или массив из 1 элемента.',
            'В языках функционального программирования нет циклов - приходится применять рекурсию и данную стратегию.',
        ],
    },
        ,{
            header: 'Быстрая сортировка',
            items: [
                'Основана на стратегии "разделяй и влавствуй".',
                'Часто применяется в реальных программах.',
                'Пустой массив и массив из одного элемента - базовый случай, их не надо сортировать.',
                'Массив их двух элементов сортируется без проблем.',
                'Массив их трех и более элементов - в массиве выбирается опопрный элемент, пока просто первый (как его правильно выбрать - дальше).',
                'Находим элементы меньшие и большие опорного - процесс разделения.',
                'После этого имеем:',
                {
                    items:['Подмассив меньших элементов.', 'Опорный элемент.', 'Подмассив больших элементов.']
                },
                'Если подмассивы были бы отсортированны, то левый подмассив-опорный элемент-правый подмассив давали бы отсортированный массив.',
                'Нужно применить алгоритм быстрой сортировки к двум подмассивам и затем объединить результат.',
                'Доказательство по индукции.',
                'Скорость зависит от выбора опорного элемента.',
                'В худшем случае - О(N*N).',
                'В среднем - О(N*logN).',
                'Сортировка слиянием всегда О(N*logN), но у нее константа(которая обычно не учитывается) больше. Здесь эта константа учитывается, так как О-большое - одинаковое.',
                'Лучший случай - является средним.',
                'Если брать опорным слуйчайный элемент - в среднем алгоритм завершится за О(N*logN).',
            ],
        }]
}