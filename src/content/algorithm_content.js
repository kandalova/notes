export const ALGORITHMS_CONTENT = {
    header: 'Алгоритмы',
    lists: [{
        header: 'Git по книге',
        items: [`<a href="https://github.com/egonSchiele/grokking_algorithms" target="_blank">egonSchiele/grokking_algorithms</a>`]
    }, {
        header: 'Время выполнения',
        items: [
            'Время выполнения алгоритмов растет с разной скоростью.',
            'О-большое - как возрастает время выполнения с ростом списка.',
            'О-большое - не сообщает время в секундах, позволяет сравнить количество операций.',
            'О-большое - определяет время выолнения в худшем случае.',
            'Константы не учитываются: O(N/2) = O(N).',
            '',
            'Линейное - максимальное количество попыток совпадает с размером списка О(n).',
            'Логарифмическое - O(logN)',
            'O(N*logN) - эффективные алгоритмы сортировки.',
            'O(N*N) - медленные алгоритмы сортировки.',
            'O(N!) - очень медленные алгоритмы сортировки.',
            'O(1) - постоянное время (независимо от размера) - операции выполняются мгновенно.',
        ],
    }, {
        header: 'Бинарный поиск',
        items: [
            'На вход - отсортирвоанный список.',
            'С каждой попыткой - отсекается половина оставшихся элементов.',
            'Нужно logN шагов.'
        ],
    }, {
        header: 'Массивы и связные списки (две структуры данных)',
        items: [
            {
                header: 'Массивы:',
                items: [
                    'Хранятся в памяти непрерывно.',
                    'При добавлении нового элемента, если рядом нет свободного места в памяти:',
                    {items: ['Переносить весь массив в другое место памяти.', 'Изначально указать размер больше - неэффективно расходуется память.']},
                    'Быстрое чтение элемента с любой позиции O(1).',
                    'Вставка элемента O(N).',
                    'Удаление элемента O(N).',

                ],
            },
            {
                header: 'Связные списки:',
                items: [
                    'Элементы списка размещаются в памяти где угодно, так как в каждом элементе хранится адрес следующего.',
                    'При добавлении элемента нет таких проблем.',
                    'Чтобы прочитать элемент из середины, нужно пройти через весь список. O(N).',
                    'Вставка элемента O(1).',
                    'Удаление элемента O(1) - если можно мгновенно получить доступ к удаляемому элементу.',
                ],
            },
        ],
    }, {
        header: 'Сортировка выбором',
        items: [
            'Для сортировки по возрстанию сначала находим самый большой элемент, затем самый большой из оставшихся и тд.',
            'О(N*N)',
        ],
    }, {
        header: 'Рекурсия',
        items: [
            'Это когда функция вызывает саму себя.',
            'Применяется тогда, когда решение становится более понятным.',
            'Рекурсия не убыстряет работу, иногда решение с циклами даже быстрее.',
            'Состоит  из базового случая (когда остановится) и рекурсивного (функция вызывает сама себя).',
            'Важно понимать - стек вызовов: когда функция вызыывается из другой функции, вызывающая функция приостанавливается, а не заканчивает работу; после выполнения вызыванной функции управление передается обратно к вызывающей и она продолжает работу.',
            'Рекурсивные функции тоже используют стек вызывов',
            'Сохранение все информации для каждого вызывова функции - могут быть большие затраты памяти:',
            {
                items: ['Использовть цикл вместо рекурсии.', 'Хвостовая рекурсия.']
            }
        ],
    }, {
        header: 'Разделяй и властвуй',
        items: [
            'Алгоритмы на базе этой стратегии - рекурсивные.',
            'Два шага:',
            {
                items: ['Определить базовый случай - простейший из всех возможных.', 'Задача делится или сокращается, пока не будет сведена к базовому случаю.']
            },
            'Алгоритм Евклида.',
            'Для массивов базовый случай - пустой массив или массив из 1 элемента.',
            'В языках функционального программирования нет циклов - приходится применять рекурсию и данную стратегию.',
        ],
    }, {
        header: 'Быстрая сортировка',
        items: [
            'Основана на стратегии "разделяй и влавствуй".',
            'Часто применяется в реальных программах.',
            'Пустой массив и массив из одного элемента - базовый случай, их не надо сортировать.',
            'Массив их двух элементов сортируется без проблем.',
            'Массив их трех и более элементов - в массиве выбирается опопрный элемент, пока просто первый (как его правильно выбрать - дальше).',
            'Находим элементы меньшие и большие опорного - процесс разделения.',
            'После этого имеем:',
            {
                items: ['Подмассив меньших элементов.', 'Опорный элемент.', 'Подмассив больших элементов.']
            },
            'Если подмассивы были бы отсортированны, то левый подмассив-опорный элемент-правый подмассив давали бы отсортированный массив.',
            'Нужно применить алгоритм быстрой сортировки к двум подмассивам и затем объединить результат.',
            'Доказательство по индукции.',
            'Скорость зависит от выбора опорного элемента.',
            'В худшем случае - О(N*N).',
            'В среднем - О(N*logN).',
            'Сортировка слиянием всегда О(N*logN), но у нее константа(которая обычно не учитывается) больше. Здесь эта константа учитывается, так как О-большое - одинаковое.',
            'Лучший случай - является средним.',
            'Если брать опорным слуйчайный элемент - в среднем алгоритм завершится за О(N*logN).',
        ],
    }, {
        header: 'Хэш-таблицы (сложная структура данных)',
        items: [
            'Хэш-функция + массив = хэш-таблица.',
            'Эта структура данных с дополнительной логикой (массивы и списки - напрямую отображают адрес памяти) - сложная структура данных.',
            'Другие названия: ассоциативные массивы, словари, отображения, хэш-карты, хэши.',
            'Работают быстро.',
            'Во многих языках есть реализация хэш-таблиц.',
            {
                header: 'Хэш-функции',
                items: [
                    'Получает строку (любые даннеы - последовательность байтов) - возвращает число.',
                    'Она должна быть последовательна: на конкретное слово всегда одно и то же число.',
                    'Разным словам - разные числа (нет).',
                    'Передаем хэш-функции слово -> она возращает число -> это число - индекс массива, где хранить данные этого слова.',
                    'Неизменно связывает название с одним индексом.',
                    'Связывет разные строки с разными индексами.',
                    'Знает размер массива и возвращает только дейтвительные индексы.',
                ]
            },
            {
                header: 'Примеры использования',
                items: [
                    {
                        header: "Для поиска",
                        items: [
                            'Отлично работают, когда нужно:',
                            'Создать связь, отображающую один объект на другой.',
                            'Найти значение в списке.',
                        ]
                    },
                    {
                        header: "Исключение дупликатов",
                        items: [
                            'Проверка ключей на присутствие.',
                        ]
                    },
                    {
                        header: "Как кэш",
                        items: [
                            'Механихм кэширования - сайт запоминаеи данные, вместо того, чтобы пересчитывать их заново.',
                            'Кэшируемые данные - хранятся в хэше.',
                            'Необходимо связать  url-адрес страницы и данные этой страницы.',
                        ]
                    }]
            },
            {
                header: 'Коллизии',
                items: [
                    'Когда двум ключам назначается один элемент массива.',
                    'Пройстейшая стратегия обхода - в элементе массива создается связанный список.',
                    'Выбор хэш-функции действительно важен: в идеале она должна распределять ключи равноверно по всему хэшу (никак не на один элемент).',
                    'Если связанный список становится слишком длинным - работа сильно замедляется. Но они не станут длинными при использовании хорошей хэш-функцииы.',
                ]
            },
            {
                header: 'Быстродействие',
                items: [
                    'В среднем - за О(1).',
                    'В худшем - за О(N).',
                    'В среднем случае - лучшее быстродействие от массивов и списков.',
                    'Для предотвращения коллизий (чтобы избежать худшего случая):',
                    {
                        items: [
                            'Низкий коэффициент заполнения.',
                            'Хорошая хэш-функция.',
                        ]
                    },
                    {
                        header:  'Коэффициент заполнения',
                        items: [
                            'Кол-во элементов в хэш-таблице / Общее количество элементов.',
                            'Изменяйте размер хэш-таблицы, когда коэфф. заполнения превышает 0.7.',
                            'Для изменения размера - выделяется новый массив (обычно вдвое больший) и заново заполняется.',
                            'Изменение размера не должно происходить слишком часто.',
                        ]
                    },
                    {
                        header:  'Хорошая хэш-функция',
                        items: [
                            'Должна обеспечивать равномерное распределение значений в массиве.',
                            'Плохая - создает скопление и порождает множетво коллизий.',
                            'Алгоритм SHA - можно использовать этот алгоритм.',
                        ]
                    },

                ]
            },
        ],
    }]
}